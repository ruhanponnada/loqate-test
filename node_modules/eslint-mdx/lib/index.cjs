'use strict';

var fs = require('node:fs');
var node_module = require('node:module');
var path = require('node:path');
var synckit = require('synckit');

const import_meta = {};
const arrayify = (...args) => args.reduce((arr, curr) => {
  arr.push(...Array.isArray(curr) ? curr : curr == null ? [] : [curr]);
  return arr;
}, []);
const getPhysicalFilename = (filename, child) => {
  try {
    if (fs.statSync(filename).isDirectory()) {
      return child || filename;
    }
  } catch (err) {
    const { code } = err;
    if (code === "ENOTDIR" || code === "ENOENT") {
      return getPhysicalFilename(path.dirname(filename), filename);
    }
  }
  return filename;
};
const getPositionAtFactory = (code) => {
  const lines = code.split("\n");
  return (offset) => {
    let currOffset = 0;
    for (const [index, line_] of lines.entries()) {
      const line = index + 1;
      const nextOffset = currOffset + line_.length;
      if (nextOffset >= offset) {
        return {
          line,
          column: offset - currOffset
        };
      }
      currOffset = nextOffset + 1;
    }
  };
};
const normalizePosition = ({
  start,
  end,
  code
}) => {
  const startOffset = start.offset;
  const endOffset = end.offset;
  const range = [startOffset, endOffset];
  const getPositionAt = code == null ? null : (
    /* istanbul ignore next -- used in worker */
    getPositionAtFactory(code)
  );
  return {
    start: startOffset,
    end: endOffset,
    loc: {
      start: (
        /* istanbul ignore next -- used in worker */
        "line" in start ? start : getPositionAt(startOffset)
      ),
      end: (
        /* istanbul ignore next -- used in worker */
        "line" in end ? end : getPositionAt(endOffset)
      )
    },
    range
  };
};
const prevCharOffsetFactory = (code) => (offset) => {
  for (let i = offset; i >= 0; i--) {
    const char = code[i];
    if (/^\S$/.test(char)) {
      return i;
    }
  }
};
const nextCharOffsetFactory = (text) => {
  const total = text.length;
  return (offset) => {
    for (let i = offset; i <= total; i++) {
      const char = text[i];
      if (/^\S$/.test(char)) {
        return i;
      }
    }
  };
};
const cjsRequire = typeof require === "undefined" ? node_module.createRequire(import_meta.url) : require;

const pkg = cjsRequire("../package.json");
const meta = { name: pkg.name, version: pkg.version };

const performSyncWork = synckit.createSyncFn(
  cjsRequire.resolve("./worker.js")
);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const DEFAULT_EXTENSIONS = [".mdx"];
const MARKDOWN_EXTENSIONS = [".md"];
class Parser {
  constructor() {
    this.parse = this.parse.bind(this);
    this.parseForESLint = this.parseForESLint.bind(this);
  }
  parse(code, options) {
    return this.parseForESLint(code, options).ast;
  }
  parseForESLint(code, {
    filePath,
    sourceType,
    ignoreRemarkConfig,
    extensions,
    markdownExtensions
  }) {
    const extname = path.extname(filePath);
    const isMdx = [...DEFAULT_EXTENSIONS, ...arrayify(extensions)].includes(
      extname
    );
    const isMarkdown = [
      ...MARKDOWN_EXTENSIONS,
      ...arrayify(markdownExtensions)
    ].includes(extname);
    if (!isMdx && !isMarkdown) {
      throw new Error(
        "Unsupported file extension, make sure setting the `extensions` or `markdownExtensions` option correctly."
      );
    }
    let result;
    try {
      result = performSyncWork({
        filePath: getPhysicalFilename(filePath),
        code,
        isMdx,
        ignoreRemarkConfig
      });
    } catch (err) {
      if (process.argv.includes("--debug")) {
        console.error(err);
      }
      const { message, line, column, place } = err;
      const point = place && ("start" in place ? place.start : place);
      throw Object.assign(
        new SyntaxError(message, {
          cause: err
        }),
        {
          lineNumber: line,
          column,
          index: (
            /* istanbul ignore next */
            point == null ? void 0 : point.offset
          )
        }
      );
    }
    const { root, body, comments, tokens } = result;
    return {
      ast: __spreadProps(__spreadValues({}, normalizePosition(root.position)), {
        type: "Program",
        // @ts-expect-error -- should we change?
        sourceType,
        body,
        comments,
        tokens
      })
    };
  }
}
const parser = new Parser();
const { parse, parseForESLint } = parser;

exports.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS;
exports.MARKDOWN_EXTENSIONS = MARKDOWN_EXTENSIONS;
exports.Parser = Parser;
exports.arrayify = arrayify;
exports.cjsRequire = cjsRequire;
exports.getPhysicalFilename = getPhysicalFilename;
exports.getPositionAtFactory = getPositionAtFactory;
exports.meta = meta;
exports.nextCharOffsetFactory = nextCharOffsetFactory;
exports.normalizePosition = normalizePosition;
exports.parse = parse;
exports.parseForESLint = parseForESLint;
exports.parser = parser;
exports.performSyncWork = performSyncWork;
exports.prevCharOffsetFactory = prevCharOffsetFactory;
