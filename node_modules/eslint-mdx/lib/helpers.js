import fs from 'node:fs';
import { createRequire } from 'node:module';
import path from 'node:path';
export const arrayify = (...args) => args.reduce((arr, curr) => {
    arr.push(...(Array.isArray(curr) ? curr : curr == null ? [] : [curr]));
    return arr;
}, []);
export const getPhysicalFilename = (filename, child) => {
    try {
        if (fs.statSync(filename).isDirectory()) {
            return child || filename;
        }
    }
    catch (err) {
        const { code } = err;
        if (code === 'ENOTDIR' || code === 'ENOENT') {
            return getPhysicalFilename(path.dirname(filename), filename);
        }
    }
    return filename;
};
export const getPositionAtFactory = (code) => {
    const lines = code.split('\n');
    return (offset) => {
        let currOffset = 0;
        for (const [index, line_] of lines.entries()) {
            const line = index + 1;
            const nextOffset = currOffset + line_.length;
            if (nextOffset >= offset) {
                return {
                    line,
                    column: offset - currOffset,
                };
            }
            currOffset = nextOffset + 1;
        }
    };
};
export const normalizePosition = ({ start, end, code, }) => {
    const startOffset = start.offset;
    const endOffset = end.offset;
    const range = [startOffset, endOffset];
    const getPositionAt = code == null
        ? null
        : getPositionAtFactory(code);
    return {
        start: startOffset,
        end: endOffset,
        loc: {
            start: 'line' in start
                ? start
                : getPositionAt(startOffset),
            end: 'line' in end
                ? end
                : getPositionAt(endOffset),
        },
        range,
    };
};
export const prevCharOffsetFactory = (code) => (offset) => {
    for (let i = offset; i >= 0; i--) {
        const char = code[i];
        if (/^\S$/.test(char)) {
            return i;
        }
    }
};
export const nextCharOffsetFactory = (text) => {
    const total = text.length;
    return (offset) => {
        for (let i = offset; i <= total; i++) {
            const char = text[i];
            if (/^\S$/.test(char)) {
                return i;
            }
        }
    };
};
export const cjsRequire = typeof require === 'undefined' ? createRequire(import.meta.url) : require;
//# sourceMappingURL=helpers.js.map